<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>akka_2</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
</head>
<body>
<h1 id="toc_0">Introduction of Akka Remote</h1>

<p>Akka 允許遠端執行 Actor, 而且內建小型的 message server，在開發時，完全不用去理會底層網路的建置。要使用 Akka Remote 功能，要特別注意每台機器要彼此看得到。也就是說在網段的安排上，每台機器要彼此可以互連，因為 Akka Remote 會在每台機器，啟一個小 server，而且會彼此互連。</p>

<p>Akka 遠端執行，分成兩種模式如下：</p>

<h2 id="toc_1">模式</h2>

<h3 id="toc_2">Lookup</h3>

<p>Lookup 是在遠端 Server，先啟動 Actor，再讓 Client 連線使用。這種模式很類似傳統的 Client/Server 架構。</p>

<h3 id="toc_3">Deployment</h3>

<p>由 Master，指定遠端的 Node 要執行那些Actor。在佈署環境時，還是需要將 Actor 放到 Node。Node 啟動時，並不會去預載要執行的 Actor，而是等待 Master 端來指定。</p>

<h2 id="toc_4">Actor 基本運作</h2>

<p>在使用 Remote 功能前，先要了解 Actor 基本運作。</p>

<h3 id="toc_5">Actor 階層關係</h3>

<p>每一個 Actor 都有一個 Supervisor，包含系統內建及自建的 Actor。如下圖：</p>

<p><img src="http://doc.akka.io/docs/akka/2.3.11/_images/guardians.png" alt="The Top-Level Supervisors"></p>

<p><strong>Image from: <a href="http://doc.akka.io/docs/akka/2.3.11/general/supervision.html">Supervision and Monitoring</a></strong></p>

<p>我們自己產生的 Actor 會被歸類在 <code>user</code> 這一群。請特別注意 <strong>user</strong>。<strong>user</strong> 在後面的談到的 Actor Path 會利用到。</p>

<p>在容錯的機制中，Supervisor 需要扮演監控及重啟 Child Actor 的角色，Akka 本身已有內建監控與重啟的 <code>Strategy</code>。如果沒有特別去 orverride，就會套用預設的機制。</p>

<h3 id="toc_6">Actor Path</h3>

<p>每一個 Actor 都會有一個 Actor Path，如下：</p>

<pre><code>&quot;akka://my-sys/user/service-a/worker1&quot;                   // purely local
&quot;akka.tcp://my-sys@host.example.com:5678/user/service-b&quot; // remote</code></pre>

<p><img src="http://doc.akka.io/docs/akka/2.3.11/_images/RemoteDeployment.png" alt="The Interplay with Remote Deployment"></p>

<p><strong>Code and image from <a href="http://doc.akka.io/docs/akka/2.3.11/general/addressing.html">Actor References, Paths and Addresses</a></strong></p>

<p>簡單來說，在單機時：</p>

<pre><code>val system = ActorSystem(&quot;HelloWorld&quot;)
val actor = system.actorOf(Props[MyActor], &quot;MyHelloWorld&quot;)</code></pre>

<p>上面 <code>actor</code> 的 path 會是 <code>akka://HelloWorld/user/MyHelloWorld</code> 也就是 <code>akka://System_Name/user/Actor_Name</code>，其中要特別注意 <strong>user</strong>，所以自己產生的 actor 都會被歸到 <strong>user</strong> 路徑下。</p>

<p>同理在遠端上 Actor path 就會像 <code>akka.tcp://HelloWorld@host:port/user/MyHelloWorld</code>。</p>

<p>如果某個 actor 是被另一個 actor 產生時，則 path 會像：</p>

<pre><code>akka://HelloWorld/user/parent/MyHelloWorld</code></pre>

<p>Actor path 在系統中，是不能重覆的，因此在為 actor 命名時，要小心。</p>

<h2 id="toc_7">實作 - 把企鵝丟到遠處</h2>

<p>延用上一篇 <strong>吃飯、睡覺、打東東</strong> 的梗，將企鵝的 Actor 放在遠端的機器上執行。<a href="https://github.com/kigichang/akka-sample">Source code</a> 放在我的 GitHub 上。</p>

<h3 id="toc_8">前置工作</h3>

<ul>
<li><p>首先要修改 <code>libraryDependencies</code> 原本是用 <del><code>&quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.4&quot;</code></del> <code>&quot;com.typesafe.akka&quot; %% &quot;akka-actor&quot; % &quot;2.3.11&quot;</code>, 改成 Remote 版本 <del><code>&quot;com.typesafe.akka&quot; %% &quot;akka-remote&quot; % &quot;2.3.4&quot;</code></del> <code>&quot;com.typesafe.akka&quot; %% &quot;akka-remote&quot; % &quot;2.3.11&quot;</code></p></li>
<li><p>在專案的目錄，新加 <code>src/main/resources</code><del>，並且加到 eclipse 專案的 <code>Source PATH</code>。這個目錄等一下要放設定檔。</del></p></li>
</ul>

<h3 id="toc_9">問題</h3>

<pre><code>package com.example

sealed trait Question
object Interest extends Serializable with Question
object Why extends Serializable with Question
</code></pre>

<p>Singleton 要繼承 <strong>Serializable</strong> 否則訊息會傳不出去。</p>

<h3 id="toc_10">回答</h3>

<p>新增 <code>PenguinReady</code></p>

<pre><code>package com.example

sealed trait Answer
case class Three(name: String, a: String, b: String, c: String) extends Answer
case class Two(name: String, a: String, b: String) extends Answer
case class Because(name: String, msg: String) extends Answer

case class PenguinReady(path: String)
</code></pre>

<h3 id="toc_11">角色</h3>

<p>原本的角色，再新增 <code>LookupReporter</code>，<code>PenguinKing</code>，<code>DepolyReporter</code>。</p>

<pre><code>package com.example

import akka.actor.Actor
import akka.actor.Props
import akka.actor.Identify
import scala.concurrent.duration.DurationInt
import akka.actor.ActorIdentity
import scala.concurrent.duration.Duration
import akka.actor.ActorRef

/**
 * 企鵝
 */
class Penguin(val name: String) extends Actor {
  def receive: Actor.Receive = {
    case Interest =&gt;
      println(s&quot;$name got Interest&quot;)
      sender() ! Three(name, &quot;吃飯&quot;, &quot;睡覺&quot;, &quot;打東東&quot;)

    case Why =&gt;

    case _ =&gt;
  }

  override def preStart() = {
    println(s&quot;$name start at ${self.path}&quot;)
  }
}

object Penguin {
  def apply(name: String): Props = Props(classOf[Penguin], name)
}

/**
 * 叫東東的企鵝
 */
class DongDong extends Penguin(&quot;東東&quot;) {

  override def receive = {
    case Interest =&gt;
      println(s&quot;$name got Interest&quot;)
      sender() ! Two(name, &quot;吃飯&quot;, &quot;睡覺&quot;)

    case Why =&gt;
      println(s&quot;$name got Why&quot;)
      sender() ! Because(name, s&quot;我就是【${name}】&quot;)

    case _ =&gt;
  }
}

object DongDong {
  val props = Props[DongDong]
}

/**
 * 記者
 */
class Reporter extends Actor {
  def receive: Actor.Receive = {

    /* 有三個興趣的回覆 */
    case Three(name, a, b, c) =&gt;
      println(s&quot;${name}: ${a}, ${b}, ${c}&quot;)

    /* 只有二個興趣的回覆，反問 why */
    case Two(name, a, b) =&gt;
      println(s&quot;${name}: ${a}, ${b}&quot;)
      sender ! Why

    /* 接到 why 的回覆 */
    case Because(name, msg) =&gt;
      println(s&quot;${name}: ${msg}&quot;)

    case _ =&gt;
  }
}

object Reporter {
  val props = Props[Reporter]
}

/**
 * Lookup 版的記者
 */
class LookupReporter(penguins: Array[String]) extends Reporter {

  var count = 0

  def sendIdentifyRequest() {
    penguins foreach { path =&gt; println(path); context.actorSelection(path) ! Identify(path) }

    context.setReceiveTimeout(5 seconds)
  }

  sendIdentifyRequest

  def myReceive: Actor.Receive = {
    case ActorIdentity(path, Some(actor)) =&gt;
      count += 1

      if (count == penguins.length) {
        context.setReceiveTimeout(Duration.Undefined)
      }

      println(s&quot;${path} found&quot;)

      actor ! Interest

    case ActorIdentity(path, None) =&gt;
      println(s&quot;${path} not found&quot;)
  }

  override def receive: Actor.Receive = myReceive orElse super.receive

  override def preStart() = {
    println(&quot;Lookup Reporter start&quot;)
  }
}

object LookupReporter {

  def apply(penguins: Array[String]) = Props(classOf[LookupReporter], penguins)
}

/**
 * 企鵝王
 */
class PenguinKing(count: Int, reporter: ActorRef) extends Actor {

  def depoly = {
    for (i &lt;- 0 until count - 1) {
      val penguin = context.actorOf(Penguin(s&quot;penguin-$i&quot;))

      penguin ! Identify(penguin.path.toString)

    }

    val dongdong = context.actorOf(DongDong.props)
    
    dongdong ! Identify(dongdong.path.toString)
  }

  depoly
  
  def receive: Actor.Receive = {
    case ActorIdentity(path, Some(actor)) =&gt;
      println(s&quot;$path found&quot;)
      reporter ! PenguinReady(path.toString)
      
    case ActorIdentity(path, None) =&gt;
      println(s&quot;$path not found&quot;)
  }
}

object PenguinKing {
  def apply(count: Int, reporter: ActorRef) = Props(classOf[PenguinKing], count, reporter)
}

/**
 * Depolyment 版記者
 */
class DepolyReporter extends Reporter {

  def myReceive: Actor.Receive = {
    case PenguinReady(path) =&gt;
      val actor = context.actorSelection(path)
      actor ! Interest
  }

  override def receive = myReceive orElse super.receive
}

object DepolyReporter {
  val props = Props[DepolyReporter]
}
</code></pre>

<h3 id="toc_12">Lookup 模式</h3>

<p>Lookup 模式像 Client/Server，比較好理解。程式分成 <code>LookupServer</code> 及 <code>LookupClient</code>。執行順序：<code>LookupServer</code> -&gt; <code>LookupClient</code>. </p>

<ul>
<li>Lookup Server</li>
</ul>

<pre><code>package com.example

import com.typesafe.config.ConfigFactory

import akka.actor.ActorRef
import akka.actor.ActorSystem

object LookupServer {

  def main(args: Array[String]) {

    val system = ActorSystem(&quot;LookupServer&quot;, ConfigFactory.load(&quot;lookup-server&quot;))

    val penguins = new Array[ActorRef](10)

    for (i &lt;- 0 to 8) {
      penguins(i) = system.actorOf(Penguin(s&quot;Penguin-$i&quot;), s&quot;penguin-$i&quot;)
      println(penguins(i).path)
    }

    penguins(9) = system.actorOf(DongDong.props, &quot;dongdong&quot;)
    println(penguins(9).path)
  }
}
</code></pre>

<p>程式跟先前的差不多，主要差別在產生 ActorSystem 時，多了一個 <code>ConfigFactory.load(&quot;lookup-server&quot;)</code>，這個就是先前提到的設定檔，在開發環境下，會去 src/main/resources/ 目錄下找 <code>lookup-server.conf</code></p>

<ul>
<li>lookup-server.conf</li>
</ul>

<pre><code>akka {
  actor {
    provider = &quot;akka.remote.RemoteActorRefProvider&quot;
  }

  remote {
    netty.tcp {
      hostname = &quot;127.0.0.1&quot;
      port = 2552
    }
  }
}
</code></pre>

<p>原則上，只要寫好設定檔，在程式開好 Actor，就完成一個可以被遠端呼叫的 Server。</p>

<ul>
<li>Lookup Client</li>
</ul>

<pre><code>package com.example

import akka.actor.ActorSystem
import com.typesafe.config.ConfigFactory

object LookupClient {

  def main(args: Array[String]) {
    val system = ActorSystem(&quot;LookupClient&quot;, ConfigFactory.load(&quot;lookup-client&quot;))

    val remotePath = &quot;akka.tcp://LookupServer@127.0.0.1:2552/user/&quot;

    val penguins = new Array[String](10)

    for (i &lt;- 0 to 8) {
      penguins(i) = s&quot;${remotePath}penguin-${i}&quot;
    }

    penguins(9) = s&quot;${remotePath}dongdong&quot;

    val reporter = system.actorOf(LookupReporter(penguins), &quot;reporter&quot;)
    println(reporter.path)

    /* 主程式等一下，要不然上面都是 non-blocking call，會直接結束程式 */
    Thread.sleep(5 * 1000)
    system.shutdown
    println(&quot;end&quot;)
  }
}
</code></pre>

<ul>
<li>lookup-client.conf</li>
</ul>

<pre><code>akka {
  actor {
    provider = &quot;akka.remote.RemoteActorRefProvider&quot;
  }

  remote {
    netty.tcp {
      hostname = &quot;127.0.0.1&quot;
      port = 2554
    }
  }
}
</code></pre>

<p>Client 程式，先準備好遠端 Actor Path，然後傳給 <code>LookupReporter</code> 去呼叫遠端的 <code>Penguin</code>。</p>

<ul>
<li>LookupReporter</li>
</ul>

<pre><code>class LookupReporter(penguins: Array[String]) extends Reporter {

  var count = 0

  def sendIdentifyRequest() {
    penguins foreach { path =&gt; println(path); context.actorSelection(path) ! Identify(path) }

    context.setReceiveTimeout(5 seconds)
  }

  sendIdentifyRequest

  
  def myReceive: Actor.Receive = {
    case ActorIdentity(path, Some(actor)) =&gt;
      count += 1

      if (count == penguins.length) {
        context.setReceiveTimeout(Duration.Undefined)
      }

      println(s&quot;${path} found&quot;)

      actor ! Interest

    case ActorIdentity(path, None) =&gt;
      println(s&quot;${path} not found&quot;)
  }
  
  override def receive: Actor.Receive = myReceive orElse super.receive

  override def preStart() = {
    println(&quot;Lookup Reporter start&quot;)
  }
}

object LookupReporter {

  def apply(penguins: Array[String]) = Props(classOf[LookupReporter], penguins)
}
</code></pre>

<p>在 <code>LookupReporter</code> 中，我們使用 Actor 內建的 <code>context</code>，來查詢遠端的 actor： <code>context.actorSelection(path)</code>。</p>

<p><code>LookupReporter</code> 跟先前一樣，但多了一個 <code>sendIdentifyRequest</code> 的函式，主要的功能是查詢遠端的 actor，是否已經 ready。在 Akka Actor 內建處理 <code>Identify</code> 的功能，我們可以對某個 Actor 傳送 <code>Identify</code>, <code>Identify</code> 的參數可以自定，用來辨識。當 Actor 是 OK 的話，則會收到 <code>ActorIdentity(id, Some(actor))</code>，其中的 <code>id</code> 就是先前在 <code>Identify</code> 加入的辨識字串。如果 Actor 沒有 Ready 好的話，則會收到 <code>ActorIdentity(id, None)</code>, 這時候，我們就可以知道那個 Actor 掛了。</p>

<p>執行起來的結果，你可以在 Server 的 console 上看到 <code>Penguin</code> output 的訊息，在 Client 端這邊，看到 <code>LookupReporter</code> 的 output。</p>

<h3 id="toc_13">Deployment 模式</h3>

<p>Deployment 模式，Master 可以指定 Actor 在那個遠端的 Node 來執行。這個範例純用設定檔的方式，來佈署 Actor。Akka 也允許在程式內，自行動態佈署。</p>

<p>執行順序：<code>DepolyNode</code> -&gt; <code>DepolyMaster</code></p>

<ul>
<li>Deploy Node - 用來執行被佈署的 Actor</li>
</ul>

<pre><code>package com.example

import akka.actor.ActorSystem
import com.typesafe.config.ConfigFactory

object DepolynNode {

  def main(args: Array[String]) {
    val system = ActorSystem(&quot;DepolyNode&quot;, ConfigFactory.load(&quot;depoly-node&quot;))
  }
}
    </code></pre>

<p>由上的範例，其實我們只要啟一個 <code>ActorSystem</code> 即可。</p>

<ul>
<li>deploy-node.conf</li>
</ul>

<pre><code>akka {
    actor {
        provider = &quot;akka.remote.RemoteActorRefProvider&quot;
    }
      
    remote {
        netty.tcp {
            hostname = &quot;127.0.0.1&quot;
            port = 2551
        }
    }
}
    </code></pre>

<p>其實跟上面的 <code>lookup-server.conf</code> 相似。</p>

<ul>
<li>deploy-master.conf</li>
</ul>

<pre><code>akka {
    actor {
        provider = &quot;akka.remote.RemoteActorRefProvider&quot;

        deployment {
            &quot;/penguin-king/*&quot; {
            remote = &quot;akka.tcp://DepolyNode@127.0.0.1:2551&quot;
        }
    }
}

    remote {
        netty.tcp {
            hostname = &quot;127.0.0.1&quot;
            port = 2553
        }
    }
}
    </code></pre>

<p>在 client 程式前，我們先看一下 client 的 conf 檔。跟先前的 <code>lookup-client.conf</code> 差不多，但多了一個 <code>deployment</code> 設定。上面的設定，是說明要將 actor path 是 <code>/penguin-king/*</code> 送到遠端 Node 執行。</p>

<ul>
<li>Deploy Master - 指定 Actor 在那些 Node 執行</li>
</ul>

<pre><code>package com.example

import com.typesafe.config.ConfigFactory
import akka.actor.ActorSystem

object DepolyMaster {

  def main(args: Array[String]) {
    val system = ActorSystem(&quot;DepolyMaster&quot;, ConfigFactory.load(&quot;depoly-master&quot;))
    
    val reporter = system.actorOf(DepolyReporter.props)
    
    val king = system.actorOf(PenguinKing(10, reporter), &quot;penguin-king&quot;)
    
    
    Thread.sleep(10 * 1000)
    
    system.shutdown()
    println(&quot;end&quot;)
  }
}
</code></pre>

<p><code>DepolyMaster</code> 開啟一個 <code>PenguinKing</code> 的 actor，且註冊 actor name 是 <code>penguin-king</code>。<code>PenguinKing</code> 用來產生 <code>Penguin</code> 及 <code>DongDong</code>。如下：</p>

<pre><code>def depoly = {
  for (i &lt;- 0 until count - 1) {
    val penguin = context.actorOf(Penguin(s&quot;penguin-$i&quot;))

    penguin ! Identify(penguin.path.toString)

  }

  val dongdong = context.actorOf(DongDong.props)
    
  dongdong ! Identify(dongdong.path.toString)
}
</code></pre>

<p>在 <code>Actor</code> 中有 <code>context</code> 可以用來產生子 actor。由於 <code>PenguinKing</code> 的 actor name 是 <code>penguin-king</code>，這些子 <code>Penguin</code> 的 path 就會變成 <code>/penguin-king/xx</code>，就符合我們在 <code>deploy-master.conf</code> 設定檔上設定的 deployment 路徑 <code>/penguin-king/*</code>，佈署後，一樣使用 <code>Identify</code> 來確認是否完成佈署。當完成佈署後，通知 <code>DepolyReporter</code> 可以問題。</p>

<p><code>PenguinKing</code> 的 <code>receive</code> 如下：</p>

<pre><code>def receive: Actor.Receive = {
  case ActorIdentity(path, Some(actor)) =&gt;
    println(s&quot;$path found&quot;)
    reporter ! PenguinReady(path.toString)
  
  case ActorIdentity(path, None) =&gt;
    println(s&quot;$path not found&quot;)
}
</code></pre>

<p><code>DepolyReporter</code> 的 <code>receive</code> 如下：</p>

<pre><code>def myReceive: Actor.Receive = {
  case PenguinReady(path) =&gt;
  val actor = context.actorSelection(path)
  actor ! Interest
}

override def receive = myReceive orElse super.receive
</code></pre>

<p>執行結果會像 lookup 模式，在 Server 端看到 <code>Penguin</code> 的 output，在 Client 端看到 <code>DepolyReporter</code> 的 output。</p>

<script type="text/x-mathjax-config">
if (typeof MathJaxListener !== 'undefined') {
  MathJax.Hub.Register.StartupHook('End', function () {
    MathJaxListener.invokeCallbackForKey_('End');
  });
}
</script>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>

</html>
